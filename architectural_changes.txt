Architectural changes:

- Add new parameter to IVault functions: bytes32 _data, optional to be used by the vault. In this case, pass user
  address.
- When depositing, create new proxy contract from vault associated with each depositor. This proxy contract will deposit
  into rocket pool.
- Create a mapping of user address to proxy contract.
- When withdrawing, withdraw from user's proxy contract.
- If user has an existing proxy contract associated, then reuse.
- Problem: how to upgrade vault?
- Possible solution
  3 contracts: 
  - RocketPoolVault (implements IVault)
      Sets storage variable in RocketPoolVaultStorage (currentImplementation
  - RocketPoolVaultStorage
      Holds storage variable currentImplementation 
      Holds mapping of user to delegate contracts
  - RocketPoolDelegate (2 functions, deposit, withdraw)
      Holds instance of RocketPoolVaultStorage
      Function modifier on both functions currentVaultImplementation
      currentVaultImplementation checks value stored in RocketPoolVaultStorage
  When upgrading, currentImplementation in RocketPoolVaultStorage gets set to new vault implementation
